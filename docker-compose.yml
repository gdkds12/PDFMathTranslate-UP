# docker-compose.yml
version: '3.8'

services:
  backend:
    build:
      context: . # Build context is the root directory
      dockerfile: Dockerfile # Use the Dockerfile in the root directory
    ports:
      - "8000:8000"
    volumes:
      # Mount .env file for Azure credentials
      - ./.env:/app/.env
      # Mount storage directory for persistent output
      - ./storage:/app/storage
      # Optional: Mount temp_files for debugging, remove in production
      # - ./temp_files:/app/temp_files
    environment:
      # Pass necessary environment variables if not solely relying on .env
      # e.g., AZURE_DEPLOYMENT_1_NAME: ${AZURE_DEPLOYMENT_1_NAME}
      PYTHONUNBUFFERED: 1 # Already set in Dockerfile, but good practice
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all # Use all available GPUs, or specify a number e.g., 1
              capabilities: [gpu]
    restart: unless-stopped # Optional: Add restart policy
    # Optional: Add healthcheck
    # healthcheck:
    #   test: ["CMD", "curl", "-f", "http://localhost:8000/"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3

  frontend: # <<< 프론트엔드 서비스 추가
    build:
      context: ./frontend # Build context is the frontend directory
      dockerfile: Dockerfile # Use the Dockerfile inside the frontend directory
    ports:
      - "3000:3000" # Expose port 3000 for the frontend
    environment:
      # <<< 중요: 프론트엔드가 백엔드를 찾을 수 있도록 URL 설정 >>>
      # Docker Compose 네트워크 내에서 'backend' 서비스 이름으로 접근
      # NEXT_PUBLIC_ 접두사는 Next.js가 브라우저 환경변수로 인식하게 함
      NEXT_PUBLIC_API_URL: http://backend:8000
    depends_on:
      - backend # 백엔드가 시작된 후 프론트엔드 시작 (네트워크 준비 보장)
    restart: unless-stopped # Optional: Add restart policy

networks:
  default:
    driver: bridge

volumes:
  storage_data: # Define named volume if not using bind mount 